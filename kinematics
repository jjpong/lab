<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理實驗模擬器</title>
    <style>
        body { font-family: Arial, sans-serif; }
        canvas { border: 1px solid black; }
        .slider-container { margin: 10px 0; }
        .slider-container label { display: inline-block; width: 120px; }
    </style>
</head>
<body>
    <h1>物理實驗模擬器</h1>
    <div class="slider-container">
        <label for="force">外力 (N):</label>
        <input type="range" id="force" min="0" max="100" value="50" step="0.1">
        <span id="forceValue">50</span>
    </div>
    <div class="slider-container">
        <label for="mass">質量 (kg):</label>
        <input type="range" id="mass" min="0.5" max="10" value="1" step="0.1">
        <span id="massValue">1</span>
    </div>
    <div class="slider-container">
        <label for="friction">摩擦係數:</label>
        <input type="range" id="friction" min="0" max="1" value="0.1" step="0.01">
        <span id="frictionValue">0.1</span>
    </div>
    <div class="slider-container">
        <label for="angle">傾斜角度 (度):</label>
        <input type="range" id="angle" min="0" max="90" value="0" step="1">
        <span id="angleValue">0</span>
    </div>
    <div class="slider-container">
        <label for="interval">時間間隔 (s):</label>
        <input type="range" id="interval" min="0.01" max="0.1" value="0.05" step="0.01">
        <span id="intervalValue">0.05</span>
    </div>
    <button id="startStop">開始/暫停</button>
    <button id="reset">重置</button>
    <br><br>
    <canvas id="simulationCanvas" width="1200" height="800"></canvas>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // 實驗參數
        let force = 50;
        let mass = 1;
        let friction_coef = 0.1;
        let angle = 0;
        let time_interval = 0.05;
        const track_length = 10;
        const g = 9.8;

        // 物體狀態
        let position = 0;
        let velocity = 0;
        let acceleration = 0;
        let time = 0;
        let positions = [];

        // 模擬狀態
        let simulating = false;

        // 軌道繪製參數
        const TRACK_START = { x: 100, y: 700 };
        const TRACK_END = { x: 1100, y: 700 };

        // 更新滑塊值顯示
        function updateSliderValue(id) {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Value');
            valueSpan.textContent = parseFloat(slider.value).toFixed(2);
            return parseFloat(slider.value);
        }

        // 初始化滑塊事件監聽器
        ['force', 'mass', 'friction', 'angle', 'interval'].forEach(id => {
            const slider = document.getElementById(id);
            slider.addEventListener('input', () => {
                window[id] = updateSliderValue(id);
            });
        });

        // 開始/暫停按鈕
        document.getElementById('startStop').addEventListener('click', () => {
            simulating = !simulating;
            if (simulating) {
                requestAnimationFrame(simulate);
            }
        });

        // 重置按鈕
        document.getElementById('reset').addEventListener('click', () => {
            position = 0;
            velocity = 0;
            time = 0;
            positions = [];
            simulating = false;
            drawSimulation();
        });

        function simulate() {
            if (!simulating) return;

            // 計算加速度
            const angle_rad = angle * Math.PI / 180;
            acceleration = (force - friction_coef * mass * g * Math.cos(angle_rad) - mass * g * Math.sin(angle_rad)) / mass;

            // 更新速度和位置
            velocity += acceleration * time_interval;
            position += velocity * time_interval + 0.5 * acceleration * time_interval ** 2;

            // 記錄位置
            time += time_interval;
            if (position <= track_length) {
                positions.push({ time, position });
            } else {
                simulating = false;
            }

            drawSimulation();

            if (simulating) {
                requestAnimationFrame(simulate);
            }
        }

        function drawSimulation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 繪製軌道
            ctx.beginPath();
            ctx.moveTo(TRACK_START.x, TRACK_START.y);
            ctx.lineTo(TRACK_END.x, TRACK_END.y);
            ctx.stroke();

            // 繪製刻度
            for (let i = 0; i <= 10; i++) {
                const x = TRACK_START.x + i * (TRACK_END.x - TRACK_START.x) / 10;
                ctx.beginPath();
                ctx.moveTo(x, TRACK_START.y);
                ctx.lineTo(x, TRACK_START.y + 10);
                ctx.stroke();
                ctx.fillText(i, x - 5, TRACK_START.y + 25);
            }

            // 繪製物體位置
            positions.forEach(pos => {
                const x = TRACK_START.x + pos.position * (TRACK_END.x - TRACK_START.x) / track_length;
                ctx.beginPath();
                ctx.arc(x, TRACK_START.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.fillText(pos.position.toFixed(2), x + 10, TRACK_START.y - 10);
            });

            // 顯示當前參數
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.fillText(`外力: ${force.toFixed(2)} N`, 10, 30);
            ctx.fillText(`質量: ${mass.toFixed(2)} kg`, 10, 50);
            ctx.fillText(`摩擦係數: ${friction_coef.toFixed(2)}`, 10, 70);
            ctx.fillText(`傾斜角度: ${angle.toFixed(2)}°`, 10, 90);
            ctx.fillText(`時間間隔: ${time_interval.toFixed(3)} s`, 10, 110);
        }

        // 初始繪製
        drawSimulation();
    </script>
</body>
</html>
