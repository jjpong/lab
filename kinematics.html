<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理實驗模擬器</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        canvas { border: 1px solid black; }
        .slider-container { margin: 10px 0; }
        .slider-container label { display: inline-block; width: 180px; }
        button { margin-right: 10px; }
    </style>
</head>
<body>
    <h1>物理實驗模擬器</h1>
    <div class="slider-container">
        <label for="force">外力 (N):</label>
        <input type="range" id="force" min="0" max="100" value="0" step="1">
        <span id="forceValue">0</span>
    </div>
    <div class="slider-container">
        <label for="mass">質量 (kg):</label>
        <input type="range" id="mass" min="0.5" max="10" value="1" step="0.1">
        <span id="massValue">1</span>
    </div>
    <div class="slider-container">
        <label for="staticFriction">最大靜摩擦力 (N):</label>
        <input type="range" id="staticFriction" min="0" max="100" value="5" step="0.1">
        <span id="staticFrictionValue">5</span>
    </div>
    <div class="slider-container">
        <label for="kineticFriction">動摩擦力 (N):</label>
        <input type="range" id="kineticFriction" min="0" max="100" value="3" step="0.1">
        <span id="kineticFrictionValue">3</span>
    </div>
    <div class="slider-container">
        <label for="interval">紀錄時間間隔 (s):</label>
        <input type="range" id="interval" min="0.01" max="1" value="0.05" step="0.01">
        <span id="intervalValue">0.05</span>
    </div>
    <button id="startStop">開始/暫停</button>
    <button id="reset">重置</button>
    <button id="plotData">繪製數據圖</button>
    <br><br>
    <canvas id="simulationCanvas" width="1000" height="600"></canvas>
    <div id="debug"></div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const debugElement = document.getElementById('debug');

        // 實驗參數
        let force = 0;
        let mass = 1;
        let staticFriction = 5;
        let kineticFriction = 3;
        let record_interval = 0.05;
        const track_length = 10; // 10 meters

        // 物體狀態
        let position = 0;
        let velocity = 0;
        let acceleration = 0;
        let time = 0;
        let lastRecordTime = 0;
        let records = [];

        // 模擬狀態
        let simulating = false;

        // 軌道繪製參數
        const TRACK_START = { x: 50, y: 400 };
        const TRACK_END = { x: 950, y: 400 };

        // 方塊大小（像素）
        const BLOCK_SIZE = 30;

        // 動畫和計算參數
        const CALCULATION_STEP = 0.01; // 計算步長（秒）

        // 更新滑塊值顯示並返回更新後的值
        function updateSliderValue(id) {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Value');
            const value = parseFloat(slider.value);
            valueSpan.textContent = value.toFixed(2);
            return value;
        }

        // 初始化滑塊事件監聽器
        ['force', 'mass', 'staticFriction', 'kineticFriction', 'interval'].forEach(id => {
            const slider = document.getElementById(id);
            slider.addEventListener('input', () => {
                if (id === 'interval') {
                    record_interval = updateSliderValue(id);
                } else if (id === 'force') {
                    force = updateSliderValue(id);
                } else if (id === 'mass') {
                    mass = updateSliderValue(id);
                } else if (id === 'staticFriction') {
                    staticFriction = updateSliderValue(id);
                    // 確保動摩擦力不大於最大靜摩擦力
                    if (kineticFriction > staticFriction) {
                        kineticFriction = staticFriction;
                        document.getElementById('kineticFriction').value = staticFriction;
                        updateSliderValue('kineticFriction');
                    }
                } else if (id === 'kineticFriction') {
                    kineticFriction = Math.min(updateSliderValue(id), staticFriction);
                }
                updateDebugInfo();
                drawSimulation();
            });
        });

        // 開始/暫停按鈕
        document.getElementById('startStop').addEventListener('click', () => {
            simulating = !simulating;
            if (simulating) {
                requestAnimationFrame(animate);
            }
        });

        // 重置按鈕
        document.getElementById('reset').addEventListener('click', () => {
            position = 0;
            velocity = 0;
            acceleration = 0;
            time = 0;
            lastRecordTime = 0;
            records = [];
            simulating = false;
            drawSimulation();
            updateDebugInfo();
        });

        // 繪製數據圖按鈕
        document.getElementById('plotData').addEventListener('click', plotTimePositionGraph);

        function calculateMotion(deltaTime) {
            let friction;
            if (Math.abs(velocity) < 0.001) { // 靜止狀態
                friction = Math.min(Math.abs(force), staticFriction) * Math.sign(-force);
            } else { // 運動狀態
                friction = kineticFriction * Math.sign(-velocity);
            }

            let netForce = force + friction;
            acceleration = netForce / mass;
            
            velocity += acceleration * deltaTime;
            position += velocity * deltaTime + 0.5 * acceleration * deltaTime * deltaTime;
            
            time += deltaTime;

            if (time - lastRecordTime >= record_interval) {
                records.push({ time, position });
                lastRecordTime = time;
            }

            if (position > track_length) {
                position = track_length;
                velocity = 0;
                simulating = false;
            } else if (position < 0) {
                position = 0;
                velocity = 0;
            }

            updateDebugInfo();
        }

        function animate() {
            if (!simulating) return;

            calculateMotion(CALCULATION_STEP);
            drawSimulation();

            if (simulating) {
                requestAnimationFrame(animate);
            }
        }

        function drawSimulation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 繪製軌道
            ctx.beginPath();
            ctx.moveTo(TRACK_START.x, TRACK_START.y);
            ctx.lineTo(TRACK_END.x, TRACK_END.y);
            ctx.stroke();

            // 繪製刻度
            for (let i = 0; i <= 10; i++) {
                const x = TRACK_START.x + i * (TRACK_END.x - TRACK_START.x) / 10;
                ctx.beginPath();
                ctx.moveTo(x, TRACK_START.y);
                ctx.lineTo(x, TRACK_START.y + 10);
                ctx.stroke();
                ctx.fillText(i, x - 5, TRACK_START.y + 25);
            }

            // 繪製移動的方塊
            const blockX = TRACK_START.x + position * (TRACK_END.x - TRACK_START.x) / track_length;
            
            // 根據質量設定顏色
            const colorIntensity = Math.floor(255 - (mass - 0.5) / 9.5 * 200);
            ctx.fillStyle = `rgb(0, 0, ${colorIntensity})`;
            ctx.fillRect(blockX - BLOCK_SIZE/2, TRACK_START.y - BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

            // 繪製力的箭頭
            const arrowLength = force * 2;
            ctx.beginPath();
            ctx.moveTo(blockX + BLOCK_SIZE/2, TRACK_START.y - BLOCK_SIZE/2);
            ctx.lineTo(blockX + BLOCK_SIZE/2 + arrowLength, TRACK_START.y - BLOCK_SIZE/2);
            ctx.stroke();
            
            // 箭頭頭部
            ctx.beginPath();
            ctx.moveTo(blockX + BLOCK_SIZE/2 + arrowLength, TRACK_START.y - BLOCK_SIZE/2);
            ctx.lineTo(blockX + BLOCK_SIZE/2 + arrowLength - 10, TRACK_START.y - BLOCK_SIZE/2 - 5);
            ctx.lineTo(blockX + BLOCK_SIZE/2 + arrowLength - 10, TRACK_START.y - BLOCK_SIZE/2 + 5);
            ctx.closePath();
            ctx.fill();

            // 繪製記錄點
            ctx.fillStyle = 'red';
            records.forEach(record => {
                const x = TRACK_START.x + record.position * (TRACK_END.x - TRACK_START.x) / track_length;
                ctx.beginPath();
                ctx.arc(x, TRACK_START.y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillText(`${record.time.toFixed(2)}s`, x - 20, TRACK_START.y - 40);
                ctx.fillText(`${record.position.toFixed(2)}m`, x - 20, TRACK_START.y - 20);
            });

            // 顯示當前參數和位置
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.fillText(`外力: ${force.toFixed(2)} N`, 10, 30);
            ctx.fillText(`質量: ${mass.toFixed(2)} kg`, 10, 50);
            ctx.fillText(`最大靜摩擦力: ${staticFriction.toFixed(2)} N`, 10, 70);
            ctx.fillText(`動摩擦力: ${kineticFriction.toFixed(2)} N`, 10, 90);
            ctx.fillText(`紀錄時間間隔: ${record_interval.toFixed(3)} s`, 10, 110);
            ctx.fillText(`位置: ${position.toFixed(2)} m`, 10, 130);
            ctx.fillText(`時間: ${time.toFixed(2)} s`, 10, 150);
            ctx.fillText(`速度: ${velocity.toFixed(2)} m/s`, 10, 170);
            ctx.fillText(`加速度: ${acceleration.toFixed(2)} m/s²`, 10, 190);
        }

        function plotTimePositionGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const graphWidth = 900;
            const graphHeight = 500;
            const graphX = 50;
            const graphY = 550;

            // 繪製座標軸
            ctx.beginPath();
            ctx.moveTo(graphX, graphY);
            ctx.lineTo(graphX, graphY - graphHeight);
            ctx.moveTo(graphX, graphY);
            ctx.lineTo(graphX + graphWidth, graphY);
            ctx.strokeStyle = 'black';
            ctx.stroke();

            // 標註軸
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.fillText('時間 (s)', graphX + graphWidth / 2, graphY + 30);
            ctx.save();
            ctx.translate(graphX - 30, graphY - graphHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('位置 (m)', 0, 0);
            ctx.restore();

            // 繪製數據點
            if (records.length > 0) {
                const maxTime = Math.max(...records.map(r => r.time));
                const maxPosition = Math.max(...records.map(r => r.position));

                records.forEach(record => {
                    const x = graphX + (record.time / maxTime) * graphWidth;
                    const y = graphY - (record.position / maxPosition) * graphHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                });
            }

            // 添加圖表標題
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText('時間-位置關係圖', graphX + graphWidth / 2 - 80, 30);
        }

        function updateDebugInfo() {
            debugElement.innerHTML = `
                Debug Info:<br>
                Force: ${force}<br>
                Mass: ${mass}<br>
                Static Friction: ${staticFriction}<br>
                Kinetic Friction: ${kineticFriction}<br>
                Acceleration: ${acceleration}<br>
                Velocity: ${velocity}<br>
                Position: ${position}<br>
                Time: ${time}
            `;
        }

        // 初始繪製
        drawSimulation();
        updateDebugInfo();
    </script>
</body>
</html>
