<!DOCTYPE html><html lang="zh-TW"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ›çš„åˆæˆèˆ‡åˆ†è§£</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }
        
        .main-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        .canvas-section {
            flex: 1;
            min-width: 300px;
            background: white;
            border-right: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            position: relative;
            overflow: hidden;
        }
        
        .resizer {
            width: 6px;
            background: #ddd;
            cursor: col-resize;
            position: relative;
            transition: background-color 0.2s;
        }
        
        .resizer:hover {
            background: #bbb;
        }
        
        .resizer::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background: #999;
            border-radius: 1px;
        }
        
        .control-section {
            width: 350px;
            min-width: 250px;
            max-width: 500px;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .control-panel {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        #forceCanvas {
            cursor: crosshair;
            border: none;
        }
        
        /* ç¹ªåœ–å·¥å…·åˆ—æ¨£å¼ */
        .drawing-toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            cursor: move;
            user-select: none;
        }
        
        .toolbar-toggle {
            padding: 8px 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .toolbar-toggle:hover {
            background: #2980b9;
        }
        
        .toolbar-content {
            display: none;
            padding: 10px;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }
        
        .toolbar-content.expanded {
            display: flex;
        }
        
        .tool-row {
            display: flex;
            gap: 5px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }
        
        .tool-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .color-btn {
            width: 24px;
            height: 24px;
            border: 2px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .color-btn.active {
            border-color: #333;
            box-shadow: 0 0 0 2px #333;
        }
        
        .stroke-btn {
            width: 30px;
            height: 20px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .stroke-btn:hover {
            background: #f0f0f0;
        }
        
        .stroke-btn.active {
            background: #3498db;
            border-color: #2980b9;
        }
        
        .stroke-line {
            width: 20px;
            height: 1px;
            background: #333;
        }
        
        .stroke-line.medium {
            height: 2px;
        }
        
        .stroke-line.thick {
            height: 3px;
        }
        
        .toolbar-divider {
            height: 1px;
            background: #ddd;
            margin: 5px 0;
        }
        
        .unit-selector {
            margin-bottom: 15px;
        }
        
        .unit-selector label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 13px;
        }
        
        .unit-selector select {
            width: 100%;
            padding: 6px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .axis-controls {
            margin-bottom: 15px;
            padding: 12px;
            background: #f0f8ff;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        
        .axis-controls h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #333;
        }
        
        .axis-info {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            flex-wrap: wrap;
        }
        
        .axis-angle-input {
            width: 60px;
            padding: 4px;
            font-size: 11px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .axis-reset-btn {
            padding: 4px 8px;
            font-size: 10px;
            border: none;
            border-radius: 3px;
            background: #4ecdc4;
            color: white;
            cursor: pointer;
        }
        
        .axis-reset-btn:hover {
            background: #45b7aa;
        }
        
        .global-controls {
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .global-controls h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #333;
        }
        
        .resultant-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .resultant-main {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
        }
        
        .resultant-main input[type="checkbox"] {
            margin-right: 6px;
        }
        
        .resultant-components {
            display: flex;
            gap: 12px;
            margin-left: 20px;
            font-size: 11px;
            flex-wrap: wrap;
        }
        
        .resultant-components input[type="checkbox"]:disabled {
            opacity: 0.5;
        }
        
        .resultant-components-toggle {
            margin: 6px 0;
            font-size: 10px;
        }
        
        .resultant-components-toggle input[type="checkbox"] {
            margin-right: 4px;
        }
        
        .force-group {
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 12px;
            background: #fafafa;
            transition: all 0.2s;
        }
        
        .force-group.active {
            background: #f0f8ff;
            border-color: #bbb;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .force-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }
        
        .force-header input[type="checkbox"] {
            margin: 0;
        }
        
        .color-indicator {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            border: 1px solid #ccc;
            flex-shrink: 0;
        }
        
        .force-name-input {
            flex: 1;
            padding: 4px 6px;
            font-size: 11px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: white;
        }
        
        .force-name-input:disabled {
            background: #f5f5f5;
            color: #999;
        }
        
        .force-values {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        
        .force-values label {
            font-size: 11px;
            min-width: 30px;
            font-weight: 500;
        }
        
        .force-values input {
            width: 50px;
            padding: 3px 4px;
            font-size: 11px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .force-components-toggle {
            margin: 6px 0;
            font-size: 10px;
        }
        
        .force-components-toggle input[type="checkbox"] {
            margin-right: 4px;
        }
        
        .component-controls {
            display: flex;
            gap: 12px;
            font-size: 10px;
            flex-wrap: wrap;
        }
        
        .component-controls label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .component-controls input[type="checkbox"] {
            margin-right: 4px;
        }
        
        .component-controls input[type="checkbox"]:disabled {
            opacity: 0.5;
        }
        
        .results-panel {
            margin-top: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }
        
        .results-panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        .result-item {
            margin-bottom: 6px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }
        
        .result-value {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .controls-section {
            margin-top: 15px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            min-width: 80px;
        }
        
        .btn-reset {
            background: #e74c3c;
            color: white;
        }
        
        .btn-reset:hover {
            background: #c0392b;
        }
        
        .btn-center {
            background: #3498db;
            color: white;
        }
        
        .btn-center:hover {
            background: #2980b9;
        }
        
        .object-info {
            margin-top: 12px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            font-size: 11px;
            border: 1px solid #d0e7ea;
        }
        
        .object-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .tips {
            font-size: 10px;
            color: #666;
            margin-top: 6px;
            line-height: 1.3;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .canvas-section {
                height: 60vh;
                border-right: none;
                border-bottom: 2px solid #ddd;
            }
            
            .resizer {
                height: 6px;
                width: 100%;
                cursor: row-resize;
            }
            
            .resizer::after {
                width: 30px;
                height: 2px;
            }
            
            .control-section {
                width: 100%;
                max-width: none;
                height: 40vh;
            }
            
            .drawing-toolbar {
                top: 5px;
                left: 5px;
            }
        }

        @media (max-width: 768px) {
            .canvas-section {
                height: 50vh;
                padding: 5px;
            }
            
            .control-section {
                height: 50vh;
            }
            
            .control-panel {
                padding: 10px;
            }
            
            .force-values {
                justify-content: space-between;
            }
            
            .component-controls {
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="canvas-section" id="canvasSection">
            <canvas id="forceCanvas"></canvas>
            
            <!-- ç¹ªåœ–å·¥å…·åˆ— -->
            <div class="drawing-toolbar" id="drawingToolbar">
                <button class="toolbar-toggle" id="toolbarToggle">
                    ğŸ¨ ç¹ªåœ–å·¥å…·
                </button>
                <div class="toolbar-content" id="toolbarContent">
                    <!-- ç¹ªåœ–å·¥å…· -->
                    <div class="tool-row">
                        <div class="tool-btn" id="tool-move" title="ç§»å‹•/é¸æ“‡">ğŸ–±ï¸</div>
                        <div class="tool-btn" id="tool-line" title="ç›´ç·š">ğŸ“</div>
                        <div class="tool-btn" id="tool-rect" title="çŸ©å½¢">â¬œ</div>
                        <div class="tool-btn" id="tool-circle" title="åœ“å½¢">â­•</div>
                        <div class="tool-btn" id="tool-triangle" title="ç›´è§’ä¸‰è§’å½¢">ğŸ“</div>
                        <div class="tool-btn" id="tool-freehand" title="è‡ªç”±ç¹ªè£½">âœï¸</div>
                    </div>
                    
                    <div class="toolbar-divider"></div>
                    
                    <!-- ç·¨è¼¯å·¥å…· -->
                    <div class="tool-row">
                        <div class="tool-btn" id="tool-delete" title="æ™ºèƒ½åˆªé™¤">ğŸ—‘ï¸</div>
                        <div class="tool-btn" id="tool-undo" title="æ’¤éŠ·">â†¶</div>
                        <div class="tool-btn" id="tool-redo" title="é‡åš">â†·</div>
                        <div class="tool-btn" id="tool-clear" title="æ¸…é™¤å…¨éƒ¨">ğŸ§¹</div>
                    </div>
                    
                    <div class="toolbar-divider"></div>
                    
                    <!-- é¡è‰²é¸æ“‡ -->
                    <div class="tool-row">
                        <div class="color-btn active" data-color="#000000" style="background-color: #000000;" title="é»‘è‰²"></div>
                        <div class="color-btn" data-color="#e74c3c" style="background-color: #e74c3c;" title="ç´…è‰²"></div>
                        <div class="color-btn" data-color="#3498db" style="background-color: #3498db;" title="è—è‰²"></div>
                        <div class="color-btn" data-color="#2ecc71" style="background-color: #2ecc71;" title="ç¶ è‰²"></div>
                        <div class="color-btn" data-color="#f39c12" style="background-color: #f39c12;" title="æ©™è‰²"></div>
                    </div>
                    
                    <div class="toolbar-divider"></div>
                    
                    <!-- ç·šæ¢ç²—ç´° -->
                    <div class="tool-row">
                        <div class="stroke-btn active" data-width="1" title="ç´°ç·š">
                            <div class="stroke-line"></div>
                        </div>
                        <div class="stroke-btn" data-width="3" title="ä¸­ç­‰">
                            <div class="stroke-line medium"></div>
                        </div>
                        <div class="stroke-btn" data-width="5" title="ç²—ç·š">
                            <div class="stroke-line thick"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="resizer" id="resizer"></div>
        
        <div class="control-section" id="controlSection">
            <div class="control-panel">
                <div class="unit-selector">
                    <label for="unitSelect">å–®ä½</label>
                    <select id="unitSelect">
                        <option value="kgw">é‡é‡ (kgw)</option>
                        <option value="N">åŠ› (N)</option>
                    </select>
                </div>

                <div class="axis-controls">
                    <h4>åº§æ¨™è»¸è¨­å®š</h4>
                    <div class="axis-info">
                        <label>è§’åº¦ï¼š</label>
                        <input type="number" id="axisAngle" class="axis-angle-input" min="-180" max="180" value="0">Â°
                        <button class="axis-reset-btn" onclick="resetAxis()">é‡ç½®</button>
                    </div>
                    <div class="tips">
                        æç¤ºï¼šå¯æ‹–æ‹½åº§æ¨™è»¸ç«¯é»ä¾†æ—‹è½‰
                    </div>
                </div>

                <div class="global-controls">
                    <h4>åˆåŠ›é¡¯ç¤º</h4>
                    <div class="resultant-controls">
                        <div class="resultant-main">
                            <input type="checkbox" id="showResultant"> é¡¯ç¤ºåˆåŠ›
                        </div>
                        <div class="resultant-components">
                            <label><input type="checkbox" id="resultant_horizontal" disabled=""> æ°´å¹³åˆ†åŠ›</label>
                            <label><input type="checkbox" id="resultant_vertical" disabled=""> å‚ç›´åˆ†åŠ›</label>
                        </div>
                        <div class="resultant-components-toggle">
                            <input type="checkbox" id="resultant_show_components" disabled=""> åœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
                        </div>
                    </div>
                </div>

                <div id="forceControls">
                    <div class="force-group" data-force="1">
                        <div class="force-header">
                            <input type="checkbox" id="f1_active">
                            <div class="color-indicator" style="background-color: #e74c3c;"></div>
                            <input type="text" class="force-name-input" id="f1_name" value="F1" disabled="">
                        </div>
                        <div class="force-values">
                            <label>å¤§å°ï¼š</label>
                            <input type="number" id="f1_magnitude" min="0" value="0">
                            <label>è§’åº¦ï¼š</label>
                            <input type="number" id="f1_angle" min="0" max="359" value="0">Â°
                        </div>
                        <div class="force-components-toggle">
                            <input type="checkbox" id="f1_show_components" disabled=""> åœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
                        </div>
                        <div class="component-controls">
                            <label><input type="checkbox" id="f1_horizontal" disabled=""> æ°´å¹³åˆ†åŠ›</label>
                            <label><input type="checkbox" id="f1_vertical" disabled=""> å‚ç›´åˆ†åŠ›</label>
                        </div>
                    </div>

                    <div class="force-group" data-force="2">
                        <div class="force-header">
                            <input type="checkbox" id="f2_active">
                            <div class="color-indicator" style="background-color: #3498db;"></div>
                            <input type="text" class="force-name-input" id="f2_name" value="F2" disabled="">
                        </div>
                        <div class="force-values">
                            <label>å¤§å°ï¼š</label>
                            <input type="number" id="f2_magnitude" min="0" value="0">
                            <label>è§’åº¦ï¼š</label>
                            <input type="number" id="f2_angle" min="0" max="359" value="90">Â°
                        </div>
                        <div class="force-components-toggle">
                            <input type="checkbox" id="f2_show_components" disabled=""> åœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
                        </div>
                        <div class="component-controls">
                            <label><input type="checkbox" id="f2_horizontal" disabled=""> æ°´å¹³åˆ†åŠ›</label>
                            <label><input type="checkbox" id="f2_vertical" disabled=""> å‚ç›´åˆ†åŠ›</label>
                        </div>
                    </div>

                    <div class="force-group" data-force="3">
                        <div class="force-header">
                            <input type="checkbox" id="f3_active">
                            <div class="color-indicator" style="background-color: #2ecc71;"></div>
                            <input type="text" class="force-name-input" id="f3_name" value="F3" disabled="">
                        </div>
                        <div class="force-values">
                            <label>å¤§å°ï¼š</label>
                            <input type="number" id="f3_magnitude" min="0" value="0">
                            <label>è§’åº¦ï¼š</label>
                            <input type="number" id="f3_angle" min="0" max="359" value="180">Â°
                        </div>
                        <div class="force-components-toggle">
                            <input type="checkbox" id="f3_show_components" disabled=""> åœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
                        </div>
                        <div class="component-controls">
                            <label><input type="checkbox" id="f3_horizontal" disabled=""> æ°´å¹³åˆ†åŠ›</label>
                            <label><input type="checkbox" id="f3_vertical" disabled=""> å‚ç›´åˆ†åŠ›</label>
                        </div>
                    </div>

                    <div class="force-group" data-force="4">
                        <div class="force-header">
                            <input type="checkbox" id="f4_active">
                            <div class="color-indicator" style="background-color: #f39c12;"></div>
                            <input type="text" class="force-name-input" id="f4_name" value="F4" disabled="">
                        </div>
                        <div class="force-values">
                            <label>å¤§å°ï¼š</label>
                            <input type="number" id="f4_magnitude" min="0" value="0">
                            <label>è§’åº¦ï¼š</label>
                            <input type="number" id="f4_angle" min="0" max="359" value="270">Â°
                        </div>
                        <div class="force-components-toggle">
                            <input type="checkbox" id="f4_show_components" disabled=""> åœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
                        </div>
                        <div class="component-controls">
                            <label><input type="checkbox" id="f4_horizontal" disabled=""> æ°´å¹³åˆ†åŠ›</label>
                            <label><input type="checkbox" id="f4_vertical" disabled=""> å‚ç›´åˆ†åŠ›</label>
                        </div>
                    </div>
                </div>

                <div class="results-panel">
                    <h3>è¨ˆç®—çµæœ</h3>
                    <div class="result-item">
                        <span>åˆåŠ›å¤§å°ï¼š</span>
                        <span class="result-value"><span id="resultant_magnitude">0</span> <span id="resultant_unit">kgw</span></span>
                    </div>
                    <div class="result-item">
                        <span>åˆåŠ›æ–¹å‘ï¼š</span>
                        <span class="result-value"><span id="resultant_angle">0</span>Â°</span>
                    </div>
                    <div class="result-item">
                        <span>æ°´å¹³åˆ†åŠ›ç¸½å’Œï¼š</span>
                        <span class="result-value"><span id="total_horizontal">0</span> <span id="horizontal_unit">kgw</span></span>
                    </div>
                    <div class="result-item">
                        <span>å‚ç›´åˆ†åŠ›ç¸½å’Œï¼š</span>
                        <span class="result-value"><span id="total_vertical">0</span> <span id="vertical_unit">kgw</span></span>
                    </div>
                </div>

                <div class="object-info">
                    <div class="object-info-row">
                        <span>ç‰©é«”ä½ç½®ï¼š</span>
                        <span class="result-value">(<span id="object_x">0</span>, <span id="object_y">0</span>)</span>
                    </div>
                    <div class="tips">
                        æç¤ºï¼šå¯æ‹–æ‹½ç‰©é«”å’ŒåŠ›å‘é‡ç®­é ­èª¿æ•´ä½ç½®
                    </div>
                </div>

                <div class="controls-section">
                    <button class="btn btn-reset" onclick="resetAll()">æ¸…é™¤å…¨éƒ¨</button>
                    <button class="btn btn-center" onclick="centerObject()">ç‰©é«”å›ä¸­å¿ƒ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨åŸŸè®Šæ•¸
        const canvas = document.getElementById('forceCanvas');
        const ctx = canvas.getContext('2d');
        const canvasSection = document.getElementById('canvasSection');
        const controlSection = document.getElementById('controlSection');
        const resizer = document.getElementById('resizer');
        
        // éŸ¿æ‡‰å¼è®Šæ•¸
        let GRID_SIZE, MAX_FORCE, GRID_COUNT_X, GRID_COUNT_Y;
        let objectPosition = { x: 0, y: 0 };
        
        // åº§æ¨™è»¸è§’åº¦ (åº¦)
        let axisRotation = 0;
        
        // æ‹–æ‹½åˆ†éš”æ¢è®Šæ•¸
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;
        
        // åŠ›çš„è³‡æ–™
        const forces = {
            1: { magnitude: 0, angle: 0, color: '#e74c3c', active: false, name: 'F1' },
            2: { magnitude: 0, angle: 90, color: '#3498db', active: false, name: 'F2' },
            3: { magnitude: 0, angle: 180, color: '#2ecc71', active: false, name: 'F3' },
            4: { magnitude: 0, angle: 270, color: '#f39c12', active: false, name: 'F4' }
        };
        
        // æ‹–æ‹½ç‹€æ…‹
        let isDragging = false;
        let dragTarget = null;
        let dragOffset = { x: 0, y: 0 };
        
        // ç¹ªåœ–åŠŸèƒ½è®Šæ•¸
        let isDrawingMode = false;
        let currentTool = null;
        let currentColor = '#000000';
        let currentStrokeWidth = 1;
        let drawingShapes = [];
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 10;
        
        // ç¹ªåœ–ç‹€æ…‹
        let isDrawing = false;
        let startPoint = null;
        let currentPath = [];
        let highlightedShape = null;
        let selectedShape = null;
        let isDraggingShape = false;
        
        // æ§åˆ¶é»ç·¨è¼¯ç›¸é—œè®Šæ•¸
        let editingShape = null;
        let editingControlPoint = null;
        let isDraggingControlPoint = false;
        
        // å·¥å…·åˆ—æ‹–æ‹½
        let isToolbarDragging = false;
        let toolbarOffset = { x: 0, y: 0 };
        
        // ä¿®æ”¹ï¼šæ ¼å­å°é½Šå‡½æ•¸ï¼Œè‡ªç”±ç¹ªåœ–ä¸å°é½Š
        function snapToGrid(x, y) {
            if (currentTool === 'freehand') {
                return { x: x, y: y }; // è‡ªç”±ç¹ªåœ–ä¸å°é½Šæ ¼å­
            }
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        }
        
        // ç²å–åœ–å½¢çš„æ§åˆ¶é»
        function getControlPoints(shape) {
            const points = [];
            
            switch (shape.type) {
                case 'line':
                    points.push({
                        type: 'endpoint',
                        x: shape.startX,
                        y: shape.startY,
                        name: 'start'
                    });
                    points.push({
                        type: 'endpoint',
                        x: shape.endX,
                        y: shape.endY,
                        name: 'end'
                    });
                    break;
                    
                case 'rect':
                    const left = Math.min(shape.startX, shape.endX);
                    const right = Math.max(shape.startX, shape.endX);
                    const top = Math.min(shape.startY, shape.endY);
                    const bottom = Math.max(shape.startY, shape.endY);
                    const centerX = (left + right) / 2;
                    const centerY = (top + bottom) / 2;
                    
                    // å››å€‹è§’é»
                    points.push({ type: 'corner', x: left, y: top, name: 'tl' });
                    points.push({ type: 'corner', x: right, y: top, name: 'tr' });
                    points.push({ type: 'corner', x: right, y: bottom, name: 'br' });
                    points.push({ type: 'corner', x: left, y: bottom, name: 'bl' });
                    
                    // æ—‹è½‰æ§åˆ¶é»ï¼ˆä¸­å¿ƒä¸Šæ–¹ï¼‰
                    points.push({
                        type: 'rotate',
                        x: centerX,
                        y: top - 30,
                        name: 'rotate'
                    });
                    break;
                    
                case 'circle':
                    const cCenterX = (shape.startX + shape.endX) / 2;
                    const cCenterY = (shape.startY + shape.endY) / 2;
                    const radius = Math.abs(shape.endX - shape.startX) / 2;
                    
                    // ä¸Šä¸‹å·¦å³å››å€‹æ§åˆ¶é»
                    points.push({ type: 'resize', x: cCenterX, y: cCenterY - radius, name: 'top' });
                    points.push({ type: 'resize', x: cCenterX + radius, y: cCenterY, name: 'right' });
                    points.push({ type: 'resize', x: cCenterX, y: cCenterY + radius, name: 'bottom' });
                    points.push({ type: 'resize', x: cCenterX - radius, y: cCenterY, name: 'left' });
                    break;
                    
                case 'triangle':
                    // ä¸‰å€‹é ‚é»
                    points.push({ type: 'vertex', x: shape.startX, y: shape.startY, name: 'vertex1' });
                    points.push({ type: 'vertex', x: shape.endX, y: shape.startY, name: 'vertex2' });
                    points.push({ type: 'vertex', x: shape.startX, y: shape.endY, name: 'vertex3' });
                    
                    // æ—‹è½‰æ§åˆ¶é»ï¼ˆé‡å¿ƒä¸Šæ–¹ï¼‰
                    const tCenterX = (shape.startX * 2 + shape.endX) / 3;
                    const tCenterY = (shape.startY * 2 + shape.endY) / 3;
                    points.push({
                        type: 'rotate',
                        x: tCenterX,
                        y: tCenterY - 30,
                        name: 'rotate'
                    });
                    break;
            }
            
            return points;
        }
        
        // ç¹ªè£½æ§åˆ¶é»
        function drawControlPoints(shape) {
            if (selectedShape === null || drawingShapes[selectedShape] !== shape) return;
            
            const points = getControlPoints(shape);
            const controlPointRadius = 4;
            
            points.forEach(point => {
                ctx.save();
                
                // è¨­å®šæ§åˆ¶é»æ¨£å¼
                if (point.type === 'rotate') {
                    ctx.strokeStyle = '#FF6B35';
                    ctx.fillStyle = 'white';
                } else {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.fillStyle = 'white';
                }
                
                ctx.lineWidth = 2;
                
                // ç¹ªè£½ç©ºå¿ƒåœ“åœˆ
                ctx.beginPath();
                ctx.arc(point.x, point.y, controlPointRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // æ—‹è½‰æ§åˆ¶é»é¡å¤–é¡¯ç¤ºè§’åº¦
                if (point.type === 'rotate' && shape.rotation !== undefined) {
                    ctx.fillStyle = '#FF6B35';
                    ctx.font = '10px Arial';
                    ctx.fillText(`${Math.round(shape.rotation || 0)}Â°`, point.x + 8, point.y - 8);
                }
                
                ctx.restore();
            });
        }
        
        // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°æ§åˆ¶é»
        function getClickedControlPoint(x, y, shape) {
            if (selectedShape === null || drawingShapes[selectedShape] !== shape) return null;
            
            const points = getControlPoints(shape);
            const tolerance = 8;
            
            for (let point of points) {
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (distance < tolerance) {
                    return point;
                }
            }
            
            return null;
        }
        
        // è™•ç†æ§åˆ¶é»æ‹–æ‹½
        function handleControlPointDrag(shape, controlPoint, newX, newY) {
            const snapped = snapToGrid(newX, newY);
            
            switch (shape.type) {
                case 'line':
                    if (controlPoint.name === 'start') {
                        shape.startX = snapped.x;
                        shape.startY = snapped.y;
                    } else if (controlPoint.name === 'end') {
                        shape.endX = snapped.x;
                        shape.endY = snapped.y;
                    }
                    break;
                    
                case 'rect':
                    if (controlPoint.type === 'corner') {
                        handleRectCornerDrag(shape, controlPoint, snapped.x, snapped.y);
                    } else if (controlPoint.type === 'rotate') {
                        handleShapeRotation(shape, newX, newY);
                    }
                    break;
                    
                case 'circle':
                    handleCircleResize(shape, controlPoint, snapped.x, snapped.y);
                    break;
                    
                case 'triangle':
                    if (controlPoint.type === 'vertex') {
                        handleTriangleVertexDrag(shape, controlPoint, snapped.x, snapped.y);
                    } else if (controlPoint.type === 'rotate') {
                        handleShapeRotation(shape, newX, newY);
                    }
                    break;
            }
        }
        
        // è™•ç†çŸ©å½¢è§’é»æ‹–æ‹½
        function handleRectCornerDrag(shape, controlPoint, newX, newY) {
            const left = Math.min(shape.startX, shape.endX);
            const right = Math.max(shape.startX, shape.endX);
            const top = Math.min(shape.startY, shape.endY);
            const bottom = Math.max(shape.startY, shape.endY);
            
            switch (controlPoint.name) {
                case 'tl': // å·¦ä¸Šè§’
                    shape.startX = newX;
                    shape.startY = newY;
                    shape.endX = right;
                    shape.endY = bottom;
                    break;
                case 'tr': // å³ä¸Šè§’
                    shape.startX = left;
                    shape.startY = newY;
                    shape.endX = newX;
                    shape.endY = bottom;
                    break;
                case 'br': // å³ä¸‹è§’
                    shape.startX = left;
                    shape.startY = top;
                    shape.endX = newX;
                    shape.endY = newY;
                    break;
                case 'bl': // å·¦ä¸‹è§’
                    shape.startX = newX;
                    shape.startY = top;
                    shape.endX = right;
                    shape.endY = newY;
                    break;
            }
        }
        
        // è™•ç†åœ“å½¢èª¿æ•´
        function handleCircleResize(shape, controlPoint, newX, newY) {
            const centerX = (shape.startX + shape.endX) / 2;
            const centerY = (shape.startY + shape.endY) / 2;
            
            let newRadius;
            
            switch (controlPoint.name) {
                case 'top':
                case 'bottom':
                    newRadius = Math.abs(newY - centerY);
                    break;
                case 'left':
                case 'right':
                    newRadius = Math.abs(newX - centerX);
                    break;
            }
            
            // ä¿æŒæ­£åœ“
            shape.startX = centerX - newRadius;
            shape.startY = centerY - newRadius;
            shape.endX = centerX + newRadius;
            shape.endY = centerY + newRadius;
        }
        
        // è™•ç†ä¸‰è§’å½¢é ‚é»æ‹–æ‹½
        function handleTriangleVertexDrag(shape, controlPoint, newX, newY) {
            switch (controlPoint.name) {
                case 'vertex1':
                    shape.startX = newX;
                    shape.startY = newY;
                    break;
                case 'vertex2':
                    shape.endX = newX;
                    shape.startY = newY; // ä¿æŒæ°´å¹³é‚Š
                    break;
                case 'vertex3':
                    shape.startX = newX; // ä¿æŒå‚ç›´é‚Š
                    shape.endY = newY;
                    break;
            }
        }
        
        // è™•ç†å½¢ç‹€æ—‹è½‰
        function handleShapeRotation(shape, mouseX, mouseY) {
            let centerX, centerY;
            
            if (shape.type === 'rect') {
                centerX = (shape.startX + shape.endX) / 2;
                centerY = (shape.startY + shape.endY) / 2;
            } else if (shape.type === 'triangle') {
                centerX = (shape.startX * 2 + shape.endX) / 3;
                centerY = (shape.startY * 2 + shape.endY) / 3;
            }
            
            const angle = Math.atan2(mouseY - centerY, mouseX - centerX) * 180 / Math.PI;
            shape.rotation = ((angle + 90) % 360 + 360) % 360; // èª¿æ•´è§’åº¦ä½¿å…¶å¾ä¸Šæ–¹é–‹å§‹
        }
        
        // ä¿®æ”¹ï¼šç¹ªè£½å½¢ç‹€æ™‚æ‡‰ç”¨æ—‹è½‰è®Šæ›
        function drawRotatedShape(shape) {
            if (shape.rotation === undefined || shape.rotation === 0) {
                // æ²’æœ‰æ—‹è½‰ï¼Œç›´æ¥ç¹ªè£½
                drawShapeGeometry(shape);
                return;
            }
            
            ctx.save();
            
            // è¨ˆç®—æ—‹è½‰ä¸­å¿ƒ
            let centerX, centerY;
            if (shape.type === 'rect') {
                centerX = (shape.startX + shape.endX) / 2;
                centerY = (shape.startY + shape.endY) / 2;
            } else if (shape.type === 'triangle') {
                centerX = (shape.startX * 2 + shape.endX) / 3;
                centerY = (shape.startY * 2 + shape.endY) / 3;
            }
            
            // ç§»å‹•åˆ°æ—‹è½‰ä¸­å¿ƒï¼Œæ—‹è½‰ï¼Œç„¶å¾Œç¹ªè£½
            ctx.translate(centerX, centerY);
            ctx.rotate(shape.rotation * Math.PI / 180);
            ctx.translate(-centerX, -centerY);
            
            drawShapeGeometry(shape);
            
            ctx.restore();
        }
        
        // æ–°å¢ï¼šç´”ç²¹çš„å½¢ç‹€å¹¾ä½•ç¹ªè£½å‡½æ•¸
        function drawShapeGeometry(shape) {
            switch (shape.type) {
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(shape.startX, shape.startY);
                    ctx.lineTo(shape.endX, shape.endY);
                    ctx.stroke();
                    break;
                case 'rect':
                    const width = shape.endX - shape.startX;
                    const height = shape.endY - shape.startY;
                    ctx.beginPath();
                    ctx.rect(shape.startX, shape.startY, width, height);
                    ctx.stroke();
                    break;
                case 'circle':
                    const centerX = (shape.startX + shape.endX) / 2;
                    const centerY = (shape.startY + shape.endY) / 2;
                    const radius = Math.abs(shape.endX - shape.startX) / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    break;
                case 'triangle':
                    drawRightTriangle(shape.startX, shape.startY, shape.endX, shape.endY);
                    break;
                case 'freehand':
                    if (shape.path.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(shape.path[0].x, shape.path[0].y);
                        for (let i = 1; i < shape.path.length; i++) {
                            ctx.lineTo(shape.path[i].x, shape.path[i].y);
                        }
                        ctx.stroke();
                    }
                    break;
            }
        }
        
        // åˆå§‹åŒ–éŸ¿æ‡‰å¼è¨­å®š
        function initResponsiveSettings() {
            const canvasRect = canvasSection.getBoundingClientRect();
            const availableWidth = canvasRect.width;
            const availableHeight = canvasRect.height;
            
            // è¨­å®šç•«å¸ƒä½”æ»¿æ•´å€‹å·¦å´å€åŸŸ
            canvas.width = availableWidth;
            canvas.height = availableHeight;
            
            // æ ¹æ“šç•«å¸ƒå¤§å°èª¿æ•´æ ¼å­è¨­å®š
            const minDimension = Math.min(availableWidth, availableHeight);
            
            if (minDimension >= 600) {
                GRID_SIZE = 20;
            } else if (minDimension >= 400) {
                GRID_SIZE = 15;
            } else if (minDimension >= 300) {
                GRID_SIZE = 12;
            } else {
                GRID_SIZE = 10;
            }
            
            // è¨ˆç®—æ ¼å­æ•¸é‡
            GRID_COUNT_X = Math.floor(availableWidth / GRID_SIZE);
            GRID_COUNT_Y = Math.floor(availableHeight / GRID_SIZE);
            
            // è¨­å®šæœ€å¤§åŠ›å€¼ç‚ºè¼ƒå¤§é‚Šçš„æ ¼å­æ•¸ï¼Œå…è¨±ç®­é ­è¶…å‡ºç•«é¢
            MAX_FORCE = Math.max(GRID_COUNT_X, GRID_COUNT_Y);
            
            // é‡ç½®ç‰©é«”ä½ç½®åˆ°ä¸­å¿ƒ
            objectPosition.x = Math.floor(GRID_COUNT_X / 2);
            objectPosition.y = Math.floor(GRID_COUNT_Y / 2);
            
            // æ›´æ–°åŠ›çš„æœ€å¤§å€¼
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`f${i}_magnitude`).max = MAX_FORCE;
            }
        }
        
        // åˆå§‹åŒ–åˆ†éš”æ¢æ‹–æ‹½åŠŸèƒ½
        function initResizer() {
            resizer.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        }
        
        function startResize(e) {
            isResizing = true;
            startX = e.clientX;
            startWidth = canvasSection.offsetWidth;
            document.body.style.cursor = 'col-resize';
            e.preventDefault();
        }
        
        function doResize(e) {
            if (!isResizing) return;
            
            const dx = e.clientX - startX;
            const newWidth = startWidth + dx;
            const minWidth = 300;
            const maxWidth = window.innerWidth - 250;
            
            if (newWidth >= minWidth && newWidth <= maxWidth) {
                canvasSection.style.flex = 'none';
                canvasSection.style.width = newWidth + 'px';
                
                // é‡æ–°è¨ˆç®—ç•«å¸ƒè¨­å®š
                setTimeout(() => {
                    initResponsiveSettings();
                    updateDisplay();
                }, 10);
            }
        }
        
        function stopResize() {
            isResizing = false;
            document.body.style.cursor = '';
        }
        
        // åˆå§‹åŒ–ç¹ªåœ–å·¥å…·åˆ—
        function initDrawingToolbar() {
            const toolbar = document.getElementById('drawingToolbar');
            const toggle = document.getElementById('toolbarToggle');
            const content = document.getElementById('toolbarContent');
            
            // å·¥å…·åˆ—å±•é–‹/æ”¶åˆ
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                const isExpanded = content.classList.contains('expanded');
                if (isExpanded) {
                    content.classList.remove('expanded');
                    currentTool = null;
                    isDrawingMode = false;
                    selectedShape = null;
                    updateToolButtons();
                } else {
                    content.classList.add('expanded');
                }
            });
            
            // å·¥å…·åˆ—æ‹–æ‹½
            toolbar.addEventListener('mousedown', startToolbarDrag);
            document.addEventListener('mousemove', doToolbarDrag);
            document.addEventListener('mouseup', stopToolbarDrag);
            
            // ç¹ªåœ–å·¥å…·æŒ‰éˆ•
            document.getElementById('tool-move').addEventListener('click', () => selectTool('move'));
            document.getElementById('tool-line').addEventListener('click', () => selectTool('line'));
            document.getElementById('tool-rect').addEventListener('click', () => selectTool('rect'));
            document.getElementById('tool-circle').addEventListener('click', () => selectTool('circle'));
            document.getElementById('tool-triangle').addEventListener('click', () => selectTool('triangle'));
            document.getElementById('tool-freehand').addEventListener('click', () => selectTool('freehand'));
            
            // ç·¨è¼¯å·¥å…·æŒ‰éˆ•
            document.getElementById('tool-delete').addEventListener('click', () => selectTool('delete'));
            document.getElementById('tool-undo').addEventListener('click', undoDrawing);
            document.getElementById('tool-redo').addEventListener('click', redoDrawing);
            document.getElementById('tool-clear').addEventListener('click', clearAllDrawings);
            
            // é¡è‰²é¸æ“‡
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentColor = btn.dataset.color;
                });
            });
            
            // ç·šæ¢ç²—ç´°é¸æ“‡
            document.querySelectorAll('.stroke-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.stroke-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentStrokeWidth = parseInt(btn.dataset.width);
                });
            });
        }
        
        function startToolbarDrag(e) {
            if (e.target.closest('.toolbar-content')) return;
            
            isToolbarDragging = true;
            const toolbar = document.getElementById('drawingToolbar');
            const rect = toolbar.getBoundingClientRect();
            toolbarOffset.x = e.clientX - rect.left;
            toolbarOffset.y = e.clientY - rect.top;
            e.preventDefault();
        }
        
        function doToolbarDrag(e) {
            if (!isToolbarDragging) return;
            
            const toolbar = document.getElementById('drawingToolbar');
            const newX = e.clientX - toolbarOffset.x;
            const newY = e.clientY - toolbarOffset.y;
            
            // é™åˆ¶åœ¨ç•«å¸ƒå€åŸŸå…§
            const maxX = canvasSection.offsetWidth - toolbar.offsetWidth;
            const maxY = canvasSection.offsetHeight - toolbar.offsetHeight;
            
            toolbar.style.left = Math.max(0, Math.min(maxX, newX)) + 'px';
            toolbar.style.top = Math.max(0, Math.min(maxY, newY)) + 'px';
        }
        
        function stopToolbarDrag() {
            isToolbarDragging = false;
        }
        
        function selectTool(tool) {
            if (tool === 'delete') {
                currentTool = 'delete';
                isDrawingMode = false;
            } else if (tool === 'move') {
                currentTool = 'move';
                isDrawingMode = false;
            } else {
                currentTool = tool;
                isDrawingMode = true;
            }
            selectedShape = null;
            editingShape = null;
            editingControlPoint = null;
            updateToolButtons();
        }
        
        function updateToolButtons() {
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (currentTool) {
                const toolBtn = document.getElementById(`tool-${currentTool}`);
                if (toolBtn) {
                    toolBtn.classList.add('active');
                }
            }
        }
        
        // ç¹ªåœ–æ­·å²ç®¡ç†
        function saveDrawingState() {
            undoStack.push(JSON.parse(JSON.stringify(drawingShapes)));
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift();
            }
            redoStack = []; // æ¸…ç©ºé‡åšå †ç–Š
        }
        
        function undoDrawing() {
            if (undoStack.length > 0) {
                redoStack.push(JSON.parse(JSON.stringify(drawingShapes)));
                drawingShapes = undoStack.pop();
                selectedShape = null;
                editingShape = null;
                editingControlPoint = null;
                updateDisplay();
            }
        }
        
        function redoDrawing() {
            if (redoStack.length > 0) {
                undoStack.push(JSON.parse(JSON.stringify(drawingShapes)));
                drawingShapes = redoStack.pop();
                selectedShape = null;
                editingShape = null;
                editingControlPoint = null;
                updateDisplay();
            }
        }
        
        function clearAllDrawings() {
            if (drawingShapes.length > 0) {
                saveDrawingState();
                drawingShapes = [];
                selectedShape = null;
                editingShape = null;
                editingControlPoint = null;
                updateDisplay();
            }
        }
        
        // åˆå§‹åŒ–
        function init() {
            initResponsiveSettings();
            initResizer();
            initDrawingToolbar();
            setupEventListeners();
            updateDisplay();
        }
        
        // è¦–çª—å¤§å°æ”¹è®Šæ™‚é‡æ–°åˆå§‹åŒ–
        window.addEventListener('resize', function() {
            if (!isResizing) {
                // é‡ç½®flexè¨­å®š
                canvasSection.style.flex = '1';
                canvasSection.style.width = '';
                
                setTimeout(() => {
                    initResponsiveSettings();
                    updateDisplay();
                }, 100);
            }
        });
        
        // è¨­å®šäº‹ä»¶ç›£è½å™¨
        function setupEventListeners() {
            // Canvas æ»‘é¼ äº‹ä»¶
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            
            // è§¸æ§äº‹ä»¶æ”¯æ´
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', handleTouch);
            
            // åº§æ¨™è»¸è§’åº¦è¼¸å…¥
            document.getElementById('axisAngle').addEventListener('input', () => {
                axisRotation = parseFloat(document.getElementById('axisAngle').value) || 0;
                updateDisplay();
            });
            
            // åˆåŠ›é¡¯ç¤ºæ§åˆ¶
            document.getElementById('showResultant').addEventListener('change', () => {
                updateResultantControlsState();
                updateDisplay();
            });
            
            document.getElementById('resultant_horizontal').addEventListener('change', updateDisplay);
            document.getElementById('resultant_vertical').addEventListener('change', updateDisplay);
            
            // åˆåŠ›åˆ†åŠ›æ•¸å€¼é¡¯ç¤ºæ§åˆ¶
            document.getElementById('resultant_show_components').addEventListener('change', updateDisplay);
            
            // æ§åˆ¶é¢æ¿äº‹ä»¶
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`f${i}_active`).addEventListener('change', () => {
                    const isChecked = document.getElementById(`f${i}_active`).checked;
                    forces[i].active = isChecked;
                    
                    // å¦‚æœæ–°å‹¾é¸ä¸”å¤§å°ç‚º0ï¼Œè¨­å®šé è¨­å€¼
                    if (isChecked && forces[i].magnitude === 0) {
                        forces[i].magnitude = Math.min(5, Math.floor(MAX_FORCE / 4));
                        document.getElementById(`f${i}_magnitude`).value = forces[i].magnitude;
                    }
                    
                    updateForceGroupState(i);
                    updateDisplay();
                });
                
                document.getElementById(`f${i}_magnitude`).addEventListener('input', () => {
                    forces[i].magnitude = parseInt(document.getElementById(`f${i}_magnitude`).value) || 0;
                    updateDisplay();
                });
                
                document.getElementById(`f${i}_angle`).addEventListener('input', () => {
                    forces[i].angle = parseInt(document.getElementById(`f${i}_angle`).value) || 0;
                    updateDisplay();
                });
                
                // åŠ›åç¨±è¼¸å…¥äº‹ä»¶
                document.getElementById(`f${i}_name`).addEventListener('input', () => {
                    const newName = document.getElementById(`f${i}_name`).value.trim();
                    forces[i].name = newName || `F${i}`;
                    updateDisplay();
                });
                
                // åˆ†åŠ›æ•¸å€¼é¡¯ç¤ºæ§åˆ¶
                document.getElementById(`f${i}_show_components`).addEventListener('change', updateDisplay);
                
                document.getElementById(`f${i}_horizontal`).addEventListener('change', updateDisplay);
                document.getElementById(`f${i}_vertical`).addEventListener('change', updateDisplay);
            }
            
            // å–®ä½é¸æ“‡å™¨
            document.getElementById('unitSelect').addEventListener('change', updateDisplay);
        }
        
        // è§¸æ§äº‹ä»¶è™•ç†
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            
            switch(e.type) {
                case 'touchstart':
                    onMouseDown(mouseEvent);
                    break;
                case 'touchmove':
                    onMouseMove(mouseEvent);
                    break;
                case 'touchend':
                    onMouseUp();
                    break;
            }
        }
        
        // é‡ç½®åº§æ¨™è»¸
        function resetAxis() {
            axisRotation = 0;
            document.getElementById('axisAngle').value = 0;
            updateDisplay();
        }
        
        // æ›´æ–°åˆåŠ›æ§åˆ¶ç‹€æ…‹
        function updateResultantControlsState() {
            const showResultant = document.getElementById('showResultant').checked;
            const horizontalCheckbox = document.getElementById('resultant_horizontal');
            const verticalCheckbox = document.getElementById('resultant_vertical');
            const showComponentsCheckbox = document.getElementById('resultant_show_components');
            
            if (showResultant) {
                horizontalCheckbox.disabled = false;
                verticalCheckbox.disabled = false;
                showComponentsCheckbox.disabled = false;
            } else {
                horizontalCheckbox.disabled = true;
                verticalCheckbox.disabled = true;
                horizontalCheckbox.checked = false;
                verticalCheckbox.checked = false;
                showComponentsCheckbox.disabled = true;
                showComponentsCheckbox.checked = false;
            }
        }
        
        // æ›´æ–°åŠ›ç¾¤çµ„ç‹€æ…‹
        function updateForceGroupState(forceNum) {
            const group = document.querySelector(`[data-force="${forceNum}"]`);
            const horizontal = document.getElementById(`f${forceNum}_horizontal`);
            const vertical = document.getElementById(`f${forceNum}_vertical`);
            const nameInput = document.getElementById(`f${forceNum}_name`);
            const showComponentsCheckbox = document.getElementById(`f${forceNum}_show_components`);
            
            if (forces[forceNum].active) {
                group.classList.add('active');
                horizontal.disabled = false;
                vertical.disabled = false;
                nameInput.disabled = false;
                showComponentsCheckbox.disabled = false;
            } else {
                group.classList.remove('active');
                horizontal.disabled = true;
                vertical.disabled = true;
                horizontal.checked = false;
                vertical.checked = false;
                nameInput.disabled = true;
                showComponentsCheckbox.disabled = true;
                showComponentsCheckbox.checked = false;
            }
        }
        
        // ç²å–åº§æ¨™è»¸ç«¯é»ä½ç½®
        function getAxisEndPoints() {
            const centerX = objectPosition.x * GRID_SIZE;
            const centerY = objectPosition.y * GRID_SIZE;
            
            const radian = axisRotation * Math.PI / 180;
            const cosAngle = Math.cos(radian);
            const sinAngle = Math.sin(radian);
            
            let xAxisPoints = [];
            
            if (Math.abs(cosAngle) > 0.001) {
                const tLeft = -centerX / cosAngle;
                const yLeft = centerY - tLeft * sinAngle;
                if (yLeft >= 0 && yLeft <= canvas.height) {
                    xAxisPoints.push({x: 0, y: yLeft});
                }
                
                const tRight = (canvas.width - centerX) / cosAngle;
                const yRight = centerY - tRight * sinAngle;
                if (yRight >= 0 && yRight <= canvas.height) {
                    xAxisPoints.push({x: canvas.width, y: yRight});
                }
            }
            
            if (Math.abs(sinAngle) > 0.001) {
                const tTop = centerY / sinAngle;
                const xTop = centerX + tTop * cosAngle;
                if (xTop >= 0 && xTop <= canvas.width) {
                    xAxisPoints.push({x: xTop, y: 0});
                }
                
                const tBottom = (centerY - canvas.height) / sinAngle;
                const xBottom = centerX + tBottom * cosAngle;
                if (xBottom >= 0 && xBottom <= canvas.width) {
                    xAxisPoints.push({x: xBottom, y: canvas.height});
                }
            }
            
            const yRadian = radian + Math.PI / 2;
            const yCosAngle = Math.cos(yRadian);
            const ySinAngle = Math.sin(yRadian);
            
            let yAxisPoints = [];
            
            if (Math.abs(yCosAngle) > 0.001) {
                const tLeft = -centerX / yCosAngle;
                const yLeft = centerY - tLeft * ySinAngle;
                if (yLeft >= 0 && yLeft <= canvas.height) {
                    yAxisPoints.push({x: 0, y: yLeft});
                }
                
                const tRight = (canvas.width - centerX) / yCosAngle;
                const yRight = centerY - tRight * ySinAngle;
                if (yRight >= 0 && yRight <= canvas.height) {
                    yAxisPoints.push({x: canvas.width, y: yRight});
                }
            }
            
            if (Math.abs(ySinAngle) > 0.001) {
                const tTop = centerY / ySinAngle;
                const xTop = centerX + tTop * yCosAngle;
                if (xTop >= 0 && xTop <= canvas.width) {
                    yAxisPoints.push({x: xTop, y: 0});
                }
                
                const tBottom = (centerY - canvas.height) / ySinAngle;
                const xBottom = centerX + tBottom * yCosAngle;
                if (xBottom >= 0 && xBottom <= canvas.width) {
                    yAxisPoints.push({x: xBottom, y: canvas.height});
                }
            }
            
            let xEnd = null, yEnd = null;
            
            if (xAxisPoints.length >= 2) {
                const positiveX = centerX + 200 * cosAngle;
                const positiveY = centerY - 200 * sinAngle;
                
                let minDist = Infinity;
                for (let point of xAxisPoints) {
                    const dist = Math.sqrt((point.x - positiveX) ** 2 + (point.y - positiveY) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        xEnd = point;
                    }
                }
            }
            
            if (yAxisPoints.length >= 2) {
                const positiveX = centerX + 200 * yCosAngle;
                const positiveY = centerY - 200 * ySinAngle;
                
                let minDist = Infinity;
                for (let point of yAxisPoints) {
                    const dist = Math.sqrt((point.x - positiveX) ** 2 + (point.y - positiveY) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        yEnd = point;
                    }
                }
            }
            
            return {
                xStart: xAxisPoints[0] || {x: centerX, y: centerY},
                xEnd: xEnd || {x: centerX + 200 * cosAngle, y: centerY - 200 * sinAngle},
                xAxisPoints: xAxisPoints,
                yStart: yAxisPoints[0] || {x: centerX, y: centerY},
                yEnd: yEnd || {x: centerX + 200 * yCosAngle, y: centerY - 200 * ySinAngle},
                yAxisPoints: yAxisPoints
            };
        }
        
        // æ»‘é¼ æŒ‰ä¸‹äº‹ä»¶ï¼ŒåŠ å…¥æ§åˆ¶é»æª¢æŸ¥
        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ç§»å‹•æ¨¡å¼è™•ç†
            if (currentTool === 'move') {
                handleMoveMouseDown(x, y);
                return;
            }
            
            // ç¹ªåœ–æ¨¡å¼è™•ç†
            if (isDrawingMode && currentTool) {
                handleDrawingMouseDown(x, y);
                return;
            }
            
            // æ™ºèƒ½åˆªé™¤æ¨¡å¼
            if (currentTool === 'delete') {
                handleDeleteClick(x, y);
                return;
            }
            
            // åŠ›å­¸æ¨¡å¼è™•ç†
            const axisPoints = getAxisEndPoints();
            const touchRadius = Math.max(8, GRID_SIZE / 2);
            
            if (axisPoints.xEnd && Math.abs(x - axisPoints.xEnd.x) < touchRadius && Math.abs(y - axisPoints.xEnd.y) < touchRadius) {
                isDragging = true;
                dragTarget = 'xAxis';
                return;
            }
            
            if (axisPoints.yEnd && Math.abs(x - axisPoints.yEnd.x) < touchRadius && Math.abs(y - axisPoints.yEnd.y) < touchRadius) {
                isDragging = true;
                dragTarget = 'yAxis';
                return;
            }
            
            const objPixelX = objectPosition.x * GRID_SIZE;
            const objPixelY = objectPosition.y * GRID_SIZE;
            
            if (Math.abs(x - objPixelX) < touchRadius && Math.abs(y - objPixelY) < touchRadius) {
                isDragging = true;
                dragTarget = 'object';
                dragOffset = { x: x - objPixelX, y: y - objPixelY };
                return;
            }
            
            for (let i = 1; i <= 4; i++) {
                if (forces[i].active && forces[i].magnitude > 0) {
                    const arrowEnd = getArrowEndPoint(i);
                    if (Math.abs(x - arrowEnd.x) < touchRadius && Math.abs(y - arrowEnd.y) < touchRadius) {
                        isDragging = true;
                        dragTarget = `force${i}`;
                        return;
                    }
                }
            }
        }
        
        // è™•ç†ç§»å‹•æ¨¡å¼æ»‘é¼ æŒ‰ä¸‹ï¼ŒåŠ å…¥æ§åˆ¶é»æª¢æŸ¥
        function handleMoveMouseDown(x, y) {
            // é¦–å…ˆæª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ç•¶å‰é¸ä¸­ç‰©ä»¶çš„æ§åˆ¶é»
            if (selectedShape !== null && drawingShapes[selectedShape]) {
                const controlPoint = getClickedControlPoint(x, y, drawingShapes[selectedShape]);
                if (controlPoint) {
                    isDraggingControlPoint = true;
                    editingShape = selectedShape;
                    editingControlPoint = controlPoint;
                    saveDrawingState();
                    return;
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ç¹ªåœ–ç‰©ä»¶
            for (let i = drawingShapes.length - 1; i >= 0; i--) {
                if (isPointInShape(x, y, drawingShapes[i])) {
                    selectedShape = i;
                    isDraggingShape = true;
                    const shape = drawingShapes[i];
                    
                    // è¨ˆç®—æ‹–æ‹½åç§»
                    if (shape.type === 'freehand') {
                        // å°æ–¼è‡ªç”±ç¹ªè£½ï¼Œè¨ˆç®—ç›¸å°æ–¼ç¬¬ä¸€å€‹é»çš„åç§»
                        dragOffset = {
                            x: x - shape.path[0].x,
                            y: y - shape.path[0].y
                        };
                    } else {
                        // å°æ–¼å¹¾ä½•åœ–å½¢ï¼Œè¨ˆç®—ç›¸å°æ–¼èµ·é»çš„åç§»
                        dragOffset = {
                            x: x - shape.startX,
                            y: y - shape.startY
                        };
                    }
                    
                    saveDrawingState();
                    updateDisplay();
                    return;
                }
            }
            
            // å¦‚æœæ²’æœ‰é»æ“Šåˆ°ç‰©ä»¶ï¼Œå–æ¶ˆé¸æ“‡
            selectedShape = null;
            editingShape = null;
            editingControlPoint = null;
            updateDisplay();
        }
        
        // ä¿®æ”¹ï¼šè™•ç†ç¹ªåœ–æ»‘é¼ æŒ‰ä¸‹ï¼Œè‡ªç”±ç¹ªåœ–ä¸å°é½Šæ ¼å­
        function handleDrawingMouseDown(x, y) {
            isDrawing = true;
            
            // å°é½Šåˆ°æ ¼å­é»ï¼ˆè‡ªç”±ç¹ªåœ–é™¤å¤–ï¼‰
            const snapped = snapToGrid(x, y);
            startPoint = snapped;
            
            if (currentTool === 'freehand') {
                currentPath = [{ x: x, y: y }]; // è‡ªç”±ç¹ªåœ–ä½¿ç”¨åŸå§‹åº§æ¨™
            }
            
            saveDrawingState();
        }
        
        // è™•ç†æ™ºèƒ½åˆªé™¤é»æ“Š
        function handleDeleteClick(x, y) {
            for (let i = drawingShapes.length - 1; i >= 0; i--) {
                if (isPointInShape(x, y, drawingShapes[i])) {
                    saveDrawingState();
                    drawingShapes.splice(i, 1);
                    if (selectedShape === i) {
                        selectedShape = null;
                        editingShape = null;
                        editingControlPoint = null;
                    } else if (selectedShape > i) {
                        selectedShape--;
                    }
                    updateDisplay();
                    break;
                }
            }
        }
        
        // æª¢æŸ¥é»æ˜¯å¦åœ¨åœ–å½¢å…§
        function isPointInShape(x, y, shape) {
            const tolerance = Math.max(5, shape.strokeWidth * 2);
            
            switch (shape.type) {
                case 'line':
                    return distanceToLine(x, y, shape.startX, shape.startY, shape.endX, shape.endY) < tolerance;
                case 'rect':
                    return isPointNearRect(x, y, shape, tolerance);
                case 'circle':
                    return isPointNearCircle(x, y, shape, tolerance);
                case 'triangle':
                    return isPointNearTriangle(x, y, shape, tolerance);
                case 'freehand':
                    return isPointNearPath(x, y, shape.path, tolerance);
                default:
                    return false;
            }
        }
        
        function distanceToLine(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projection = { x: x1 + t * dx, y: y1 + t * dy };
            return Math.sqrt((px - projection.x) ** 2 + (py - projection.y) ** 2);
        }
        
        function isPointNearRect(x, y, shape, tolerance) {
            const left = Math.min(shape.startX, shape.endX);
            const right = Math.max(shape.startX, shape.endX);
            const top = Math.min(shape.startY, shape.endY);
            const bottom = Math.max(shape.startY, shape.endY);
            
            return (distanceToLine(x, y, left, top, right, top) < tolerance ||
                    distanceToLine(x, y, right, top, right, bottom) < tolerance ||
                    distanceToLine(x, y, right, bottom, left, bottom) < tolerance ||
                    distanceToLine(x, y, left, bottom, left, top) < tolerance);
        }
        
        function isPointNearCircle(x, y, shape, tolerance) {
            const centerX = (shape.startX + shape.endX) / 2;
            const centerY = (shape.startY + shape.endY) / 2;
            const radius = Math.abs(shape.endX - shape.startX) / 2;
            const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            return Math.abs(distance - radius) < tolerance;
        }
        
        function isPointNearTriangle(x, y, shape, tolerance) {
            // ç›´è§’ä¸‰è§’å½¢çš„ä¸‰å€‹é ‚é»
            const x1 = shape.startX;
            const y1 = shape.startY;
            const x2 = shape.endX;
            const y2 = shape.startY;
            const x3 = shape.startX;
            const y3 = shape.endY;
            
            return (distanceToLine(x, y, x1, y1, x2, y2) < tolerance ||
                    distanceToLine(x, y, x2, y2, x3, y3) < tolerance ||
                    distanceToLine(x, y, x3, y3, x1, y1) < tolerance);
        }
        
        function isPointNearPath(x, y, path, tolerance) {
            for (let i = 1; i < path.length; i++) {
                if (distanceToLine(x, y, path[i-1].x, path[i-1].y, path[i].x, path[i].y) < tolerance) {
                    return true;
                }
            }
            return false;
        }
        
        // ä¿®æ”¹ï¼šæ»‘é¼ ç§»å‹•äº‹ä»¶ï¼Œè‡ªç”±ç¹ªåœ–ä¸å°é½Šæ ¼å­ï¼ŒåŠ å…¥æ§åˆ¶é»æ‹–æ‹½è™•ç†
        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // è™•ç†æ§åˆ¶é»æ‹–æ‹½
            if (isDraggingControlPoint && editingShape !== null && editingControlPoint) {
                handleControlPointDrag(drawingShapes[editingShape], editingControlPoint, x, y);
                updateDisplay();
                return;
            }
            
            // è™•ç†æ‹–æ‹½ç¹ªåœ–ç‰©ä»¶
            if (isDraggingShape && selectedShape !== null) {
                const snapped = snapToGrid(x - dragOffset.x, y - dragOffset.y);
                moveShape(selectedShape, snapped.x, snapped.y);
                updateDisplay();
                return;
            }
            
            // è™•ç†æ™ºèƒ½åˆªé™¤çš„é«˜äº®é¡¯ç¤º
            if (currentTool === 'delete') {
                highlightedShape = null;
                for (let i = drawingShapes.length - 1; i >= 0; i--) {
                    if (isPointInShape(x, y, drawingShapes[i])) {
                        highlightedShape = i;
                        break;
                    }
                }
                updateDisplay();
                return;
            }
            
            // è™•ç†ç§»å‹•æ¨¡å¼çš„é«˜äº®é¡¯ç¤º
            if (currentTool === 'move' && !isDraggingShape && !isDraggingControlPoint) {
                highlightedShape = null;
                for (let i = drawingShapes.length - 1; i >= 0; i--) {
                    if (isPointInShape(x, y, drawingShapes[i])) {
                        highlightedShape = i;
                        break;
                    }
                }
                updateDisplay();
                return;
            }
            
            // ç¹ªåœ–æ¨¡å¼è™•ç†
            if (isDrawing && currentTool) {
                if (currentTool === 'freehand') {
                    // è‡ªç”±ç¹ªåœ–ä¸å°é½Šæ ¼å­
                    currentPath.push({ x: x, y: y });
                    updateDisplay();
                } else {
                    updateDisplay();
                    const snapped = snapToGrid(x, y);
                    drawPreviewShape(snapped.x, snapped.y);
                }
                return;
            }
            
            // åŠ›å­¸æ¨¡å¼æ‹–æ‹½è™•ç†
            if (!isDragging) return;
            
            if (dragTarget === 'xAxis' || dragTarget === 'yAxis') {
                const centerX = objectPosition.x * GRID_SIZE;
                const centerY = objectPosition.y * GRID_SIZE;
                
                const dx = x - centerX;
                const dy = y - centerY;
                
                let newAngle;
                if (dragTarget === 'xAxis') {
                    newAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                } else {
                    newAngle = Math.atan2(-dy, dx) * 180 / Math.PI - 90;
                }
                
                while (newAngle > 180) newAngle -= 360;
                while (newAngle < -180) newAngle += 360;
                
                axisRotation = newAngle;
                document.getElementById('axisAngle').value = Math.round(newAngle);
                updateDisplay();
                
            } else if (dragTarget === 'object') {
                const newX = Math.round((x - dragOffset.x) / GRID_SIZE);
                const newY = Math.round((y - dragOffset.y) / GRID_SIZE);
                
                objectPosition.x = Math.max(0, Math.min(GRID_COUNT_X - 1, newX));
                objectPosition.y = Math.max(0, Math.min(GRID_COUNT_Y - 1, newY));
                
                updateObjectPosition();
                updateDisplay();
            } else if (dragTarget.startsWith('force')) {
                const forceNum = parseInt(dragTarget.replace('force', ''));
                updateForceFromMouse(forceNum, x, y);
            }
        }
        
        // ç§»å‹•ç¹ªåœ–åœ–å½¢
        function moveShape(shapeIndex, newX, newY) {
            const shape = drawingShapes[shapeIndex];
            
            if (shape.type === 'freehand') {
                const deltaX = newX - shape.path[0].x;
                const deltaY = newY - shape.path[0].y;
                
                shape.path = shape.path.map(point => ({
                    x: point.x + deltaX,
                    y: point.y + deltaY
                }));
            } else {
                const deltaX = newX - shape.startX;
                const deltaY = newY - shape.startY;
                
                shape.startX = newX;
                shape.startY = newY;
                shape.endX += deltaX;
                shape.endY += deltaY;
            }
        }
        
        // ç¹ªè£½é è¦½åœ–å½¢
        function drawPreviewShape(currentX, currentY) {
            if (!startPoint) return;
            
            ctx.save();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentStrokeWidth;
            ctx.globalAlpha = 0.7;
            
            switch (currentTool) {
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    break;
                case 'rect':
                    const width = currentX - startPoint.x;
                    const height = currentY - startPoint.y;
                    ctx.beginPath();
                    ctx.rect(startPoint.x, startPoint.y, width, height);
                    ctx.stroke();
                    break;
                case 'circle':
                    const centerX = (startPoint.x + currentX) / 2;
                    const centerY = (startPoint.y + currentY) / 2;
                    const radius = Math.abs(currentX - startPoint.x) / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    break;
                case 'triangle':
                    drawRightTrianglePreview(startPoint.x, startPoint.y, currentX, currentY);
                    break;
            }
            
            ctx.restore();
        }
        
        function drawRightTrianglePreview(startX, startY, endX, endY) {
            // ç›´è§’ä¸‰è§’å½¢ï¼šç›´è§’åœ¨èµ·é»ï¼Œä¸€é‚Šæ°´å¹³ï¼Œä¸€é‚Šå‚ç›´
            ctx.beginPath();
            ctx.moveTo(startX, startY);      // èµ·é»ï¼ˆç›´è§’é ‚é»ï¼‰
            ctx.lineTo(endX, startY);        // æ°´å¹³é‚Š
            ctx.lineTo(startX, endY);        // å‚ç›´é‚Š
            ctx.closePath();
            ctx.stroke();
        }
        
        // æ»‘é¼ é‡‹æ”¾äº‹ä»¶ï¼ŒåŠ å…¥æ§åˆ¶é»æ‹–æ‹½è™•ç†
        function onMouseUp() {
            if (isDrawing && currentTool) {
                finishDrawing();
            }
            
            isDragging = false;
            dragTarget = null;
            isDrawing = false;
            startPoint = null;
            currentPath = [];
            isDraggingShape = false;
            isDraggingControlPoint = false;
            editingControlPoint = null;
        }
        
        // å®Œæˆç¹ªåœ–
        function finishDrawing() {
            if (!startPoint) return;
            
            const lastMouseEvent = window.lastMouseEvent;
            if (!lastMouseEvent) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            const finalX = lastMouseEvent.clientX - canvasRect.left;
            const finalY = lastMouseEvent.clientY - canvasRect.top;
            const snappedEnd = snapToGrid(finalX, finalY);
            
            // å°æ–¼è‡ªç”±ç¹ªè£½ï¼Œä½¿ç”¨ç•¶å‰è·¯å¾‘
            if (currentTool === 'freehand' && currentPath.length > 1) {
                drawingShapes.push({
                    type: 'freehand',
                    path: [...currentPath],
                    color: currentColor,
                    strokeWidth: currentStrokeWidth
                });
            } else if (currentTool !== 'freehand') {
                drawingShapes.push({
                    type: currentTool,
                    startX: startPoint.x,
                    startY: startPoint.y,
                    endX: snappedEnd.x,
                    endY: snappedEnd.y,
                    color: currentColor,
                    strokeWidth: currentStrokeWidth,
                    rotation: 0 // åˆå§‹æ—‹è½‰è§’åº¦
                });
            }
            
            updateDisplay();
        }
        
        // æ›´æ–°æœ€å¾Œçš„æ»‘é¼ äº‹ä»¶ï¼ˆç”¨æ–¼ç²å–æœ€çµ‚ä½ç½®ï¼‰
        document.addEventListener('mousemove', (e) => {
            window.lastMouseEvent = e;
        });
        
        // å¾æ»‘é¼ ä½ç½®æ›´æ–°åŠ›
        function updateForceFromMouse(forceNum, mouseX, mouseY) {
            const objPixelX = objectPosition.x * GRID_SIZE;
            const objPixelY = objectPosition.y * GRID_SIZE;
            
            const dx = mouseX - objPixelX;
            const dy = mouseY - objPixelY;
            
            const gridX = Math.round(dx / GRID_SIZE);
            const gridY = Math.round(dy / GRID_SIZE);
            
            const actualDx = gridX * GRID_SIZE;
            const actualDy = gridY * GRID_SIZE;
            
            const distance = Math.sqrt(actualDx * actualDx + actualDy * actualDy);
            const gridDistance = Math.round(distance / GRID_SIZE);
            const magnitude = Math.min(MAX_FORCE, Math.max(0, gridDistance));
            
            let angle = Math.atan2(-actualDy, actualDx) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            
            forces[forceNum].magnitude = magnitude;
            forces[forceNum].angle = Math.round(angle);
            
            document.getElementById(`f${forceNum}_magnitude`).value = magnitude;
            document.getElementById(`f${forceNum}_angle`).value = Math.round(angle);
            
            updateDisplay();
        }
        
        // ç²å–ç®­é ­çµ‚é»
        function getArrowEndPoint(forceNum) {
            const force = forces[forceNum];
            const objPixelX = objectPosition.x * GRID_SIZE;
            const objPixelY = objectPosition.y * GRID_SIZE;
            
            const length = force.magnitude * GRID_SIZE;
            const radian = force.angle * Math.PI / 180;
            
            return {
                x: objPixelX + length * Math.cos(radian),
                y: objPixelY - length * Math.sin(radian)
            };
        }
        
        // å°‡åŠ›æŠ•å½±åˆ°æ—‹è½‰åº§æ¨™è»¸
        function projectForceToRotatedAxis(force) {
            const radian = force.angle * Math.PI / 180;
            const axisRadian = axisRotation * Math.PI / 180;
            
            const forceX = force.magnitude * Math.cos(radian);
            const forceY = force.magnitude * Math.sin(radian);
            
            const rotatedX = forceX * Math.cos(axisRadian) + forceY * Math.sin(axisRadian);
            const rotatedY = -forceX * Math.sin(axisRadian) + forceY * Math.cos(axisRadian);
            
            return { x: rotatedX, y: rotatedY };
        }
        
        // æ›´æ–°ç‰©é«”ä½ç½®é¡¯ç¤º
        function updateObjectPosition() {
            document.getElementById('object_x').textContent = objectPosition.x;
            document.getElementById('object_y').textContent = objectPosition.y;
        }
        
        // ç¹ªè£½å‡½æ•¸
        function updateDisplay() {
            clearCanvas();
            drawGrid();
            drawDrawings(); // ç¹ªåœ–åœ¨èƒŒæ™¯å±¤
            drawAxes();
            drawObject();
            drawForces();
            
            if (document.getElementById('showResultant').checked) {
                drawParallelogram();
                drawResultant();
                drawResultantComponents();
            }
            
            // ä¿®æ”¹ï¼šç¹ªè£½è‡ªç”±ç¹ªè£½çš„ç•¶å‰è·¯å¾‘ï¼Œä¸å°é½Šæ ¼å­
            if (isDrawing && currentTool === 'freehand' && currentPath.length > 1) {
                ctx.save();
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentStrokeWidth;
                ctx.globalAlpha = 0.7;
                
                ctx.beginPath();
                ctx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                ctx.stroke();
                
                ctx.restore();
            }
            
            updateResults();
        }
        
        // æ¸…é™¤ç•«å¸ƒ
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // ç¹ªè£½æ ¼å­
        function drawGrid() {
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i <= GRID_COUNT_X; i++) {
                const x = i * GRID_SIZE;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= GRID_COUNT_Y; i++) {
                const y = i * GRID_SIZE;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // ä¿®æ”¹ï¼šç¹ªè£½æ‰€æœ‰ç¹ªåœ–å…ƒç´ ï¼Œä½¿ç”¨æ—‹è½‰åŠŸèƒ½
        function drawDrawings() {
            drawingShapes.forEach((shape, index) => {
                ctx.save();
                
                // å¦‚æœæ˜¯é«˜äº®çš„åœ–å½¢ï¼Œä½¿ç”¨ç‰¹æ®Šé¡è‰²
                if (highlightedShape === index) {
                    ctx.strokeStyle = '#ff6b35';
                    ctx.lineWidth = shape.strokeWidth + 2;
                } else if (selectedShape === index) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = shape.strokeWidth + 1;
                } else {
                    ctx.strokeStyle = shape.color;
                    ctx.lineWidth = shape.strokeWidth;
                }
                
                // ä½¿ç”¨æ—‹è½‰åŠŸèƒ½ç¹ªè£½å½¢ç‹€
                drawRotatedShape(shape);
                ctx.restore();
                
                // ç¹ªè£½æ§åˆ¶é»ï¼ˆåªæœ‰åœ¨ç§»å‹•æ¨¡å¼ä¸‹é¸ä¸­çš„åœ–å½¢æ‰é¡¯ç¤ºï¼‰
                if (currentTool === 'move' && selectedShape === index) {
                    drawControlPoints(shape);
                }
            });
        }
        
        function drawRightTriangle(startX, startY, endX, endY) {
            // ç›´è§’ä¸‰è§’å½¢ï¼šç›´è§’åœ¨èµ·é»ï¼Œä¸€é‚Šæ°´å¹³ï¼Œä¸€é‚Šå‚ç›´
            ctx.beginPath();
            ctx.moveTo(startX, startY);      // èµ·é»ï¼ˆç›´è§’é ‚é»ï¼‰
            ctx.lineTo(endX, startY);        // æ°´å¹³é‚Š
            ctx.lineTo(startX, endY);        // å‚ç›´é‚Š
            ctx.closePath();
            ctx.stroke();
        }
        
        // ç¹ªè£½åº§æ¨™è»¸ï¼ˆæ”¹ç‚ºç°è‰²ï¼Œæ¯”ç¶²æ ¼æ·±ä¸€é»ï¼Œç¨ç²—ä¸€äº›ï¼‰
        function drawAxes() {
            const axisPoints = getAxisEndPoints();
            
            // åº§æ¨™è»¸ä½¿ç”¨ç°è‰²ï¼Œæ¯”ç¶²æ ¼æ·±ï¼Œç¨ç²—ä¸€äº›
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1.5;
            
            if (axisPoints.xAxisPoints.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(axisPoints.xAxisPoints[0].x, axisPoints.xAxisPoints[0].y);
                ctx.lineTo(axisPoints.xAxisPoints[1].x, axisPoints.xAxisPoints[1].y);
                ctx.stroke();
            }
            
            if (axisPoints.yAxisPoints.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(axisPoints.yAxisPoints[0].x, axisPoints.yAxisPoints[0].y);
                ctx.lineTo(axisPoints.yAxisPoints[1].x, axisPoints.yAxisPoints[1].y);
                ctx.stroke();
            }
            
            const circleRadius = Math.max(4, GRID_SIZE / 3);
            // ç«¯é»åœ“åœˆä¹Ÿä½¿ç”¨ç°è‰²ç³»
            ctx.fillStyle = '#999999';
            ctx.strokeStyle = '#777777';
            ctx.lineWidth = Math.max(1, GRID_SIZE / 12);
            
            if (axisPoints.xEnd) {
                ctx.beginPath();
                ctx.arc(axisPoints.xEnd.x, axisPoints.xEnd.y, circleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#555555';
                ctx.font = `bold ${Math.max(10, GRID_SIZE * 0.8)}px Arial`;
                ctx.fillText('X', axisPoints.xEnd.x + circleRadius + 2, axisPoints.xEnd.y + 3);
            }
            
            if (axisPoints.yEnd) {
                ctx.beginPath();
                ctx.arc(axisPoints.yEnd.x, axisPoints.yEnd.y, circleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#555555';
                ctx.font = `bold ${Math.max(10, GRID_SIZE * 0.8)}px Arial`;
                ctx.fillText('Y', axisPoints.yEnd.x + circleRadius + 2, axisPoints.yEnd.y + 3);
            }
        }
        
        // ç¹ªè£½ç‰©é«”
        function drawObject() {
            const x = objectPosition.x * GRID_SIZE;
            const y = objectPosition.y * GRID_SIZE;
            const radius = Math.max(6, GRID_SIZE / 2);
            
            ctx.fillStyle = '#ccc';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = Math.max(1, GRID_SIZE / 10);
            ctx.stroke();
            
            const crossSize = radius * 0.7;
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - crossSize, y);
            ctx.lineTo(x + crossSize, y);
            ctx.moveTo(x, y - crossSize);
            ctx.lineTo(x, y + crossSize);
            ctx.stroke();
        }
        
        // ç¹ªè£½åŠ›å‘é‡
        function drawForces() {
            for (let i = 1; i <= 4; i++) {
                if (forces[i].active && forces[i].magnitude > 0) {
                    drawForceVector(i);
                    
                    if (document.getElementById(`f${i}_horizontal`).checked) {
                        drawRotatedComponent(i, 'horizontal');
                    }
                    if (document.getElementById(`f${i}_vertical`).checked) {
                        drawRotatedComponent(i, 'vertical');
                    }
                }
            }
        }
        
        // ç¹ªè£½å¹³è¡Œå››é‚Šå½¢
        function drawParallelogram() {
            const activeForcesArray = [];
            for (let i = 1; i <= 4; i++) {
                if (forces[i].active && forces[i].magnitude > 0) {
                    activeForcesArray.push(i);
                }
            }
            
            if (activeForcesArray.length !== 2) return;
            
            const force1 = activeForcesArray[0];
            const force2 = activeForcesArray[1];
            
            const startX = objectPosition.x * GRID_SIZE;
            const startY = objectPosition.y * GRID_SIZE;
            
            const length1 = forces[force1].magnitude * GRID_SIZE;
            const radian1 = forces[force1].angle * Math.PI / 180;
            const end1X = startX + length1 * Math.cos(radian1);
            const end1Y = startY - length1 * Math.sin(radian1);
            
            const length2 = forces[force2].magnitude * GRID_SIZE;
            const radian2 = forces[force2].angle * Math.PI / 180;
            const end2X = startX + length2 * Math.cos(radian2);
            const end2Y = startY - length2 * Math.sin(radian2);
            
            const end3X = end1X + length2 * Math.cos(radian2);
            const end3Y = end1Y - length2 * Math.sin(radian2);
            
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.setLineDash([Math.max(4, GRID_SIZE / 3), Math.max(4, GRID_SIZE / 3)]);
            
            ctx.beginPath();
            ctx.moveTo(end1X, end1Y);
            ctx.lineTo(end3X, end3Y);
            ctx.moveTo(end2X, end2Y);
            ctx.lineTo(end3X, end3Y);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        // ç¹ªè£½å–®å€‹åŠ›å‘é‡ï¼Œåœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
        function drawForceVector(forceNum) {
            const force = forces[forceNum];
            const startX = objectPosition.x * GRID_SIZE;
            const startY = objectPosition.y * GRID_SIZE;
            
            const length = force.magnitude * GRID_SIZE;
            const radian = force.angle * Math.PI / 180;
            
            const endX = startX + length * Math.cos(radian);
            const endY = startY - length * Math.sin(radian);
            
            // ä½¿ç”¨ä¸­ç­‰ç²—ç´° (3)
            drawArrow(startX, startY, endX, endY, force.color, 3);
            
            const labelX = startX + (length * 0.6) * Math.cos(radian);
            const labelY = startY - (length * 0.6) * Math.sin(radian);
            
            ctx.fillStyle = force.color;
            ctx.font = `bold ${Math.max(12, GRID_SIZE * 0.8)}px Arial`;
            
            // æ ¹æ“šè¨­å®šé¡¯ç¤ºæ•¸å€¼
            const showValue = document.getElementById(`f${forceNum}_show_components`).checked;
            if (showValue) {
                const unit = document.getElementById('unitSelect').value;
                const multiplier = unit === 'N' ? 10 : 1;
                const value = (force.magnitude * multiplier).toFixed(1);
                ctx.fillText(`${force.name} = ${value} ${unit}`, labelX + 3, labelY - 3);
            } else {
                ctx.fillText(force.name, labelX + 3, labelY - 3);
            }
        }
        
        // ç¹ªè£½åŸºæ–¼æ—‹è½‰åº§æ¨™è»¸çš„åˆ†åŠ›ï¼Œåœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
        function drawRotatedComponent(forceNum, direction) {
            const force = forces[forceNum];
            const startX = objectPosition.x * GRID_SIZE;
            const startY = objectPosition.y * GRID_SIZE;
            
            const projected = projectForceToRotatedAxis(force);
            const axisRadian = axisRotation * Math.PI / 180;
            
            let endX, endY;
            
            if (direction === 'horizontal') {
                const componentLength = projected.x * GRID_SIZE;
                endX = startX + componentLength * Math.cos(axisRadian);
                endY = startY - componentLength * Math.sin(axisRadian);
            } else {
                const componentLength = projected.y * GRID_SIZE;
                endX = startX - componentLength * Math.sin(axisRadian);
                endY = startY - componentLength * Math.cos(axisRadian);
            }
            
            // ä½¿ç”¨ç¨ç´°çš„ç·šæ¢ (2)
            drawDashedArrow(startX, startY, endX, endY, force.color, 2);
            
            const suffix = direction === 'horizontal' ? 'x' : 'y';
            ctx.fillStyle = force.color;
            ctx.font = `${Math.max(10, GRID_SIZE * 0.6)}px Arial`;
            
            // æ ¹æ“šè¨­å®šé¡¯ç¤ºæ•¸å€¼
            const showValue = document.getElementById(`f${forceNum}_show_components`).checked;
            if (showValue) {
                const unit = document.getElementById('unitSelect').value;
                const multiplier = unit === 'N' ? 10 : 1;
                const value = (projected[direction === 'horizontal' ? 'x' : 'y'] * multiplier).toFixed(1);
                ctx.fillText(`${force.name}${suffix} = ${value} ${unit}`, endX + 2, endY - 2);
            } else {
                ctx.fillText(`${force.name}${suffix}`, endX + 2, endY - 2);
            }
        }
        
        // ç¹ªè£½åˆåŠ›ï¼Œåœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
        function drawResultant() {
            const activeForcesCount = Object.values(forces).filter(f => f.active && f.magnitude > 0).length;
            if (activeForcesCount === 0) return;
            
            const resultant = calculateResultant();
            if (resultant.magnitude === 0) return;
            
            const startX = objectPosition.x * GRID_SIZE;
            const startY = objectPosition.y * GRID_SIZE;
            
            const length = resultant.magnitude * GRID_SIZE;
            const radian = resultant.angle * Math.PI / 180;
            
            const endX = startX + length * Math.cos(radian);
            const endY = startY - length * Math.sin(radian);
            
            // ä½¿ç”¨è¼ƒç²—çš„ç·šæ¢ (4)
            drawArrow(startX, startY, endX, endY, '#000', 4);
            
            const labelX = startX + (length * 0.7) * Math.cos(radian);
            const labelY = startY - (length * 0.7) * Math.sin(radian);
            
            ctx.fillStyle = '#000';
            ctx.font = `bold ${Math.max(14, GRID_SIZE * 1.0)}px Arial`;
            
            // æ ¹æ“šè¨­å®šé¡¯ç¤ºæ•¸å€¼
            const showValue = document.getElementById('resultant_show_components').checked;
            if (showValue) {
                const unit = document.getElementById('unitSelect').value;
                const multiplier = unit === 'N' ? 10 : 1;
                const value = (resultant.magnitude * multiplier).toFixed(1);
                ctx.fillText(`åˆåŠ› = ${value} ${unit}`, labelX + 3, labelY - 3);
            } else {
                ctx.fillText('åˆåŠ›', labelX + 3, labelY - 3);
            }
        }
        
        // ç¹ªè£½åˆåŠ›çš„åˆ†åŠ›ï¼Œåœ¨ç•«å¸ƒä¸Šé¡¯ç¤ºæ•¸å€¼
        function drawResultantComponents() {
            const resultant = calculateResultant();
            if (resultant.magnitude === 0) return;
            
            const startX = objectPosition.x * GRID_SIZE;
            const startY = objectPosition.y * GRID_SIZE;
            
            const projectedResultant = {
                magnitude: resultant.magnitude,
                angle: resultant.angle
            };
            const projected = projectForceToRotatedAxis(projectedResultant);
            const axisRadian = axisRotation * Math.PI / 180;
            
            const showValue = document.getElementById('resultant_show_components').checked;
            const unit = document.getElementById('unitSelect').value;
            const multiplier = unit === 'N' ? 10 : 1;
            
            if (document.getElementById('resultant_horizontal').checked) {
                const componentLength = projected.x * GRID_SIZE;
                const endX = startX + componentLength * Math.cos(axisRadian);
                const endY = startY - componentLength * Math.sin(axisRadian);
                
                // ä½¿ç”¨ä¸­ç­‰ç²—ç´° (3)
                drawDashedArrow(startX, startY, endX, endY, '#000', 3);
                
                ctx.fillStyle = '#000';
                ctx.font = `bold ${Math.max(12, GRID_SIZE * 0.7)}px Arial`;
                
                if (showValue) {
                    const value = (projected.x * multiplier).toFixed(1);
                    ctx.fillText(`åˆåŠ›x = ${value} ${unit}`, endX + 2, endY - 2);
                } else {
                    ctx.fillText('åˆåŠ›x', endX + 2, endY - 2);
                }
            }
            
            if (document.getElementById('resultant_vertical').checked) {
                const componentLength = projected.y * GRID_SIZE;
                const endX = startX - componentLength * Math.sin(axisRadian);
                const endY = startY - componentLength * Math.cos(axisRadian);
                
                // ä½¿ç”¨ä¸­ç­‰ç²—ç´° (3)
                drawDashedArrow(startX, startY, endX, endY, '#000', 3);
                
                ctx.fillStyle = '#000';
                ctx.font = `bold ${Math.max(12, GRID_SIZE * 0.7)}px Arial`;
                
                if (showValue) {
                    const value = (projected.y * multiplier).toFixed(1);
                    ctx.fillText(`åˆåŠ›y = ${value} ${unit}`, endX + 2, endY - 2);
                } else {
                    ctx.fillText('åˆåŠ›y', endX + 2, endY - 2);
                }
            }
        }
        
        // ç¹ªè£½ç®­é ­
        function drawArrow(startX, startY, endX, endY, color, lineWidth) {
            const headSize = Math.max(4, GRID_SIZE / 2);
            const angle = Math.atan2(endY - startY, endX - startX);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6), 
                      endY - headSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6), 
                      endY - headSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }
        
        // ç¹ªè£½è™›ç·šç®­é ­
        function drawDashedArrow(startX, startY, endX, endY, color, lineWidth) {
            const headSize = Math.max(3, GRID_SIZE / 3);
            const angle = Math.atan2(endY - startY, endX - startX);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([Math.max(3, GRID_SIZE / 4), Math.max(3, GRID_SIZE / 4)]);
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6), 
                      endY - headSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6), 
                      endY - headSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }
        
        // è¨ˆç®—åˆåŠ›
        function calculateResultant() {
            let totalX = 0;
            let totalY = 0;
            
            for (let i = 1; i <= 4; i++) {
                if (forces[i].active && forces[i].magnitude > 0) {
                    const radian = forces[i].angle * Math.PI / 180;
                    totalX += forces[i].magnitude * Math.cos(radian);
                    totalY += forces[i].magnitude * Math.sin(radian);
                }
            }
            
            const magnitude = Math.sqrt(totalX * totalX + totalY * totalY);
            let angle = Math.atan2(totalY, totalX) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            
            return {
                magnitude: magnitude,
                angle: angle,
                x: totalX,
                y: totalY
            };
        }
        
        // æ›´æ–°çµæœé¡¯ç¤º
        function updateResults() {
            const resultant = calculateResultant();
            const unit = document.getElementById('unitSelect').value;
            const multiplier = unit === 'N' ? 10 : 1;
            
            document.getElementById('resultant_magnitude').textContent = 
                (resultant.magnitude * multiplier).toFixed(1);
            document.getElementById('resultant_angle').textContent = 
                resultant.angle.toFixed(1);
            
            const projectedResultant = projectForceToRotatedAxis({
                magnitude: resultant.magnitude,
                angle: resultant.angle
            });
            
            document.getElementById('total_horizontal').textContent = 
                (projectedResultant.x * multiplier).toFixed(1);
            document.getElementById('total_vertical').textContent = 
                (projectedResultant.y * multiplier).toFixed(1);
            
            document.getElementById('resultant_unit').textContent = unit;
            document.getElementById('horizontal_unit').textContent = unit;
            document.getElementById('vertical_unit').textContent = unit;
        }
        
        // é‡ç½®æ‰€æœ‰è¨­å®š
        function resetAll() {
            for (let i = 1; i <= 4; i++) {
                forces[i].magnitude = 0;
                forces[i].active = false;
                forces[i].name = `F${i}`;
                
                document.getElementById(`f${i}_active`).checked = false;
                document.getElementById(`f${i}_magnitude`).value = 0;
                document.getElementById(`f${i}_name`).value = `F${i}`;
                document.getElementById(`f${i}_horizontal`).checked = false;
                document.getElementById(`f${i}_vertical`).checked = false;
                document.getElementById(`f${i}_show_components`).checked = false;
                
                updateForceGroupState(i);
            }
            
            document.getElementById('showResultant').checked = false;
            document.getElementById('resultant_horizontal').checked = false;
            document.getElementById('resultant_vertical').checked = false;
            document.getElementById('resultant_show_components').checked = false;
            updateResultantControlsState();
            
            axisRotation = 0;
            document.getElementById('axisAngle').value = 0;
            
            selectedShape = null;
            editingShape = null;
            editingControlPoint = null;
            
            updateDisplay();
        }
        
        // ç‰©é«”å›åˆ°ä¸­å¿ƒ
        function centerObject() {
            objectPosition = { x: Math.floor(GRID_COUNT_X / 2), y: Math.floor(GRID_COUNT_Y / 2) };
            updateObjectPosition();
            updateDisplay();
        }
        
        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>


</body></html>
